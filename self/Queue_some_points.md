# Queue_some_points

- 큐(Queue): 

  - 먼저 집어 넣은 데이터가 먼저 나오는 FIFO구조로 저장하는 형식, Queue는 표를 사러 일렬로 늘어선 사람들로 이루어진 줄을 말하기도 한다.
  - 전단은 front(head), 후단은 rear(tail)라고 명칭, 데이터의 위치를 가리킨다. front는 데이터를 put할 수 있는 위치를, rear는 데이터가 있어 get할 수 있는 위치를 말한다.
  - 큐에 저장된 자료는 선형 구조를 갖는다.

- 선형 큐:

  - 1차원 배열을 이용한 큐.
  - 큐의 크기는 배열의 크기와 같다.
  - 지정된 첫 번째 원소의 인덱스를 front라 하고, 지정된 마지막원소의 인덱스를 rear라 한다.
  - 초기 상태: front = rear = -1
  - 공백 상태: front = rear
  - 포화 상태: rear = n - 1 (n: 배열의 크기, n-1: 배열의 마지막 index)
  - enQueue를 하게 될 경우, 먼저 Queue가 가득 차 있는지 확인 후, 공간이 있으면 rear를 이동후 집어넣음.
  - deQueue를 할 경우, Queue가 비어있는지 확인 후 item이 들어 있으면, front를 뒤로 이동, 해당 인덱스에 있는 값을 return
  - 문제점:
    - 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 공간이 있는데도 어느 순간 rear가 끝에 다다르게 되면, 포화 상태로 인식하게 된다.
  - 해결 방법:
    1. 매 연산이 이루어질 때마다 저장된 원소를 앞부분으로 모두 이동시키는 방법, 원소 이동에 시간이 많이 소요되어 큐의 효율성이 급격히 떨어짐
    2. 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용.

- 원형 큐:

  - 선형 큐에서 인덱스를 회전시켜서 만듬.
  - 초기 공백 상태: front = rear = 0
  - 인덱스의 순환: front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 한다. 이를 위해 mod를 사용
  - front 변수는 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둔다.
  - 삽입 위치 및 삭제 위치의 비교
    - 선형큐
      - 삽입위치: rear = rear + 1
      - 삭제위치: front = front + 1
    - 원형큐
      - 삽입위치: rear = (rear + 1) mod n
      - 삭제위치: front = (front + 1) mod n
  - 원형큐에 front가 위치한 배열을 제외하고 데이터가 전부 있는 경우에는 데이터가 더 이상 들어가지 못하는 포화상태가 됨. = ((rear + 1) mod n = front )

- 연결 리스트 큐:

  - 단순 연결 리스트를 사용.
  - 큐의 원소: 단순 연결 리스트의 노드
  - 큐의 원소 순서: 노드의 연결 순서 (링크로 연결되어 있음)
  - front: 첫 번째 노드를 가리키는 링크 (노드가 아니다.)
  - rear: 마지막 노드를 가리키는 링크
  - 첫번째 삽입시에는 front와 rear 둘 다 움직이고, 그 이후에는 삽입시에 rear만 움직인다.

- 우선 순위 큐:

  - 우선순위를 가진 항목들을 저장하는 큐
  - 큐의 특성인 선입선출 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 됨.
  - 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제의 테스크 스케줄링 등에 적용됨.
  - 우선 순위 큐는 세가지로 나뉨. 
    1. 배열을 기반으로 구현하는 방법
    2. 연결리스트를 기반으로 구현하는 방법
    3. 힙(Heap)을 이용하는 방법
  - 삭제 시에 우선순위가 높은 데이터가 먼저 삭제
  - 배열을 이용하여 구현시:
    -  데이터 우선순위가 높을수록 배열의 앞 쪽에 데이터를 위치시킴. 
    - 데이터 삽입과 꺼낸 후에 우선순위를 위해 데이터를 한 칸씩 뒤로 밀거나 한 칸씩 앞으로 당기는 연산을 수반해야 함으로, 소요되는 시간과 메모리 낭비가 클 수도 있다.
  - 연결리스트를 이요하여 구현시:
    - 배열처럼 데이터를 한 칸씩 당기거나 밀어야하는 연산시의 문제는 해결
    - 삽입의 위치를 찾기위해 모든 노드의 우선순위를 비교해야 할 수도 있는 문제점 존재
    - 따라서, 우선순위 큐를 구현할 때, 단순 배열이나 연결리스트가 아닌 힙이라는 자료구조를 이용하여 구현하는 것이 일반적.

- 너비 우선 탐색:

  - 깊이 우선 탐색과는 달리 스택을 이용하지  않고, 큐를 이용한다.
  - 깊이 우선 탐색처럼 무작정 막힐 때까지 탐색을 진행하는 것이 아니라, 이곳 저곳 살펴보면서 탐색을 진행.
  - 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식

  