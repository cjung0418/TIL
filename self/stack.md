# stack

stack?:

```
물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
스택에 저장된 자료는 선형구조를 가짐 cf) 선형구조: 자료 간의 관계가 1대1, 비선형구조: 1대N의 관계 ex)트리
스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있음
마지막에 삽입한 자료를 가장 먼저 꺼냄 (LIFO,Last-in-First_Out)

```

구현:

```
자료를 선형으로 저장할 저장소 필요.
c-배열, python-list
저장소 자체를 스택이라 부르기도 함.
스택에서 마지막 삽입된 원소의 위치를 top이라 부름.
연산: 삽입(push),삭제(pop),isEmpty(공백인지 확인),peek(top의 원소 반환)
ex) push a->push b-> push c:
abc <-top
pop:
ab <-top
push 알고리즘: 
def push(item):
	s.append(item) (단,s는 저장할 공간)
pop 알고리즘:
def pop():
	if len(s)==0:
		return
	else:
		return s.pop(-1)

스택 구현 고려사항:
-리스트 사용시
장점: 구현이 용이
단점: 리스트의 크기를 변경하는 작업은 내부적으로 큰 overhead 발생 작업으로 많은 시간이 소요
->해결방법: 리스트의 크기가 변동되지 않도록 배열처럼 크기를 미리 정해놓고 사용하는 방법, 동적 연결리스트를 이용하여 저장소를 동적으로 할당하여 스택을 구현하는 방법
->장점: 구현이 용이, 단점: 리스트로 구현하는 것보다 구현이 복잡.
```

stack의 응용:

```
괄호검사
종류:대괄호,중괄호,소괄호
조건:1.왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 함
2.같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 함
3.괄호 사이에는 포함 관계만 존재
스택을 이용한 괄호 검사
여는 괄호 push, 닫는 괄호 pop
괄호 조사 알고리즘:
문자열에 있는 괄호를 차례대로 조사->왼쪽 괄호를 만나면 스택에 삽입, 오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지 확인->위배:스택이 비어있음, 괄호의 짝이 맞지 않음, 문자열 끝까지 조사한 후에도 스택에 괄호가 남아 있음
함수 호출 관리:프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리, 구체적 과정: 가장 마지막에 호출된 함수가 가장 먼저 실행 완료하고 복귀하는 후입선출 구조, 따라서 스택을 이용하여 수행순서 관리-> 함수 호출이 발생하면 호출한 함수 스택에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽임-> 함수의 실행이 끝나면 시스템 스택의 top원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어있던 복귀주소를 확인하고 복귀 -> 함수 호출과 복귀에 따라  반복 모든 게 끝나면 시스템 스택은 공백 스택이 됨.
ex)main->f1내의 f2->f2의 실행 ->f1내의 f2-> main의 f1->끝
재귀 호출: 자기 자신을 호출하여 순환 수행되는 것, 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀 호출 방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성할 수 있음, 디버깅이 어렵고 잘못 작성시 수행시간이 많이 걸림
ex)factorial(4): fact(4)=4*fact(3),fact(3)=3*fact(2),fact(2)=2*fact(1),fact(1)=1
```

memoization:

```
피보나치 수열:0과1로 시작하여 이전의 두 수 합을 다음항으로 갖는 수열
F_0 = 0, F_1 = 1, F_i = F_i-1 + F_i-2 for i>=2
알고리즘:
def fibo(n):
	if n<2:
		return n
	else:
		return fibo(n-1) + fibo(n-2)
->중복호출 문제
->메모이제이션:컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장하여 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술, DP(동적계획법)의 핵심이 되는 기술
메모이제이션 != 메모리제이션
Memoization 이용한 알고리즘:
def fibo1(n):
	global memo
	if n>= 2 and len(memo) <= n:
		memo.append(fibo1(n-1)+fibo1(n-2))
	return memo[n]
	
memo = [0,1]
	
```

DP(동적 계획법):

```
Dynamic Programmiong: 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘, 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결, 최종적으로 원래 주어진 입력의 문제를 해결
피보나치에 적용:
1.문제를 부분 문제로 분할->fibo(n)은 fibo(n-1)과 fibo(n-2)의 합, fibo(n-1)은 fibo(n-2)와 fibo(n-3)의 합,...,
결과적으로 fibo(n)은 fibo(n-1),...fibo(1),fibo(0)의 부분집합으로 나뉘게 됨
2.부분 문제로 나누는 일을 끝냈으면 가장 작은 부분 문제부터 해를 구함
3.그 결과를 테이블에 저장, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구함
적용한 알고리즘:
def fibo2(n):
	f=[0,1]
	for i in range(2,n+1):
		f.append(f[i-1]+f[i-2])
	return f[n]

DP의 구현 방식:recursive 방식, iterative 방식
recursive: fibo1(), 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 overhead가 발생할 수 있음
iterative: fibo2(), Memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적
```

DFS(깊이 우선 탐색):

```
그래프의 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색 -> 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 돌아옴 -> 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하여 순회 -> 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택을 사용
알고리즘:
시작 정점 v를 결정하여 방문->정점 v에 인접한 정점 중에서 
if 방문하지 않은 정점 w가 존재하면:
	정점 v를 스택에 push하고 정점 w를 v로 하여 다시 위의 과정 반복
elif 방문하지 않은 정점이 존재X:
	탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 위의 과정 반복)
ex)
visited[],stack[]
DFS(v)
	v 방문:
	visted[v] <-true:
	do {
		if (v의 인접 정점 중 방문 안 한 w찾기)
			push(v);
		while(w){
			w방문;
			visited[w]<-true;
			push(w);
			v<-w;
			v의 인접 정점 중 방문 안 한 w찾기
		}
		v<-pop(stack);
	}while(v)
end DFS()
```

